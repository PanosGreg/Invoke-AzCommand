

New feature ideas for the Invoke-AzCommand
------------------------------------------

Ideas as of: 07-Nov-2023

0) Write integration pester tests for the public function
   Run all the functionality tests mentioned at the end of
   the .Tests.ps1
   
   Also run that in a Linux box as well

1) -AsJob parameter    -- DONE
   Look at the spinner module for this
   
2) PSDrive with the logs
   - Input.Script
   - Input.Arguments
   - Output.Results
   - Output.Errors
   - Timestamp
   - TargetVMs
   - AzUserName
   - TotalDuration
   - Unique ID of command
   - Reason (for Jira tickets)
   
   Get an idea from AWS SSM Run Command
   and the History of commands
   
   May even use SQLite for this.

   Actually, this might be a whole new module on its own.
   On the Invoke-AzCommand, just fire an event with all the relevant data (see above)
   and then that new module, will create the PS drive, register to that queue
   and also update the SQLite DB to persist the data.
   
3) PSDrive with Configuration
   OR -AzSessionOption [AzSessionOption]
   and then New-AzSessionOption
   like New-PSSessionOption or New-PesterConfiguration
   
   And add everything in the config
   - Serialization type: xml|json
   - Serialization Depth
   - Compression on/off
   - Add Az Properties on/off
   - Log on/off
   
   The idea here is, to add all options
   that you would have as feature flags.
   
4) -ReferenceModule and -ReferenceFunction parameters
   To copy and load the module(s)/function(s)
   onto the remote machine, so the user can use them
   inside his scriptblock.
   Load them up in the runspace job as context.
   
5) Encryption of user code and args as well as returned results
   This might need the extra Encipher-String module
   instead of having that logic in the AzCommand module

6) -Credential to run the remote command as that user   --- DONE
   As-in spawn a process in the remote VM with RunAs
   
   Might need some C# code here to do the impersonation

6a) If I add the credential parameter, then it makes sense to   --- DONE
    also implement encryption. Since we don't want the user/pass
    to be send in clear over the channel.

7) -Reason or -Description param [optional], so user can add any context
   on why/what he's doing.
   Most common use-case would be to put the Jira ticket ID in that
   param. So you can trace it back to a ticket or add the output log to that ticket.
   
8) [maybe] Add a copy functionality from local to the remote VMs
   just like Copy-Item that can work through PSSessions, or just
   like SSH where you can use it to copy files via SCP (secure copy)

   I could do this either directly, as-in spin up a server locally
   and then have the VM connect to that server, or vice versa (as-in
   spin up the server on the VM and have your local connect to it, but
   that needs the VM to be publicly available). Another way is to have
   an intermediate. Like S3 or GitHub or Azure NAS drive or anything else.

   This functionality could probably be done on a separate module perhaps.
   So maybe not in the same module as Invoke-AzCommand but as an additional
   module, just like the idea for the logging

9) Add a PreScript (or Before) and a PostScript (or After), so the user can do
   any needed setup and then teardown apart from his scriptblock.

   The idea is very much the same just like the Before/After blocks in Pester,
   or the Begin/End block in foreach-object, or just like the AWS SSM document
   AWS-RunPatchBaselineWithHooks where you have a pre and a post script.

   For example, in the Before block you may need to stop and disable the chef client
   scheduled task and then on the After block enable it back again.

   Similarly you may need to drain a server first (like remove it from LB forwarding
   list or failover a DB, etc), and once you're done, undrain it.

   And then keep that same Before/After and use it on many different Invoke-AzCommand scripts.
    